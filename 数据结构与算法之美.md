# 数据结构与算法之美

### 开篇词 | 从今天起，跨过“数据结构与算法”这道坎

### 01 | 为什么要学习数据结构和算法？

### 02 | 如何抓住重点，系统高效地学习数据结构与算法？

***什么是数据结构？什么是算法？***

从广义上讲，数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。

从狭义上讲，也就是我们专栏要讲的，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。

数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

***学习的重点在什么地方？***

数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！

在学习数据结构和算法的过程中，你也要注意，不要只是死记硬背，不要为了学习而学习，而是要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”。

学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动地记忆，要多辩证地思考，多问为什么。

***一些可以让你事半功倍的学习技巧***

边学边练，适度刷题

多问、多思考、多互动

打怪升级学习法

知识需要沉淀，不要想试图一下子掌握所有

### 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？

***为什么需要复杂度分析？***

**事后统计法**

我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。

测试结果非常依赖测试环境

测试结果受数据规模的影响很大

我们需要一个不用具体的测试数据，就可以粗略地估计算法的执行效率的方法。这就是我们今天要讲的时间、空间复杂度分析方法。

***大 O 复杂度表示法***

所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

![大 O 复杂度表示法](https://github.com/songor/algorithm-learned/blob/master/大 O 复杂度表示法.jpg)

T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行次数的总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略，我们只需要记录一个最大量级就可以了。

***时间复杂度分析***

只关注循环执行次数最多的那一段代码

加法法则：总复杂度等于量级最大的那段代码的复杂度

乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

***几种常见时间复杂度实例分析***

![复杂度量级](https://github.com/songor/algorithm-learned/blob/master/复杂度量级.jpg)

对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O($2^n$) 和 O(n!)。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

**O(1)**

只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

**O(logn)、O(nlogn)**

```java
i = 1;
while (i <= n) {
  i = i * 2;
}
```

实际上，变量 i 的取值就是一个等比数列。

![等比数列](https://github.com/songor/algorithm-learned/blob/master/等比数列.jpg)

所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。

x=$log_2 n$，所以，这段代码的时间复杂度就是 O($log_2 n$)。

实际上，不管是以 2 为底，还是以 3 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。

对数之间是可以互相转换的，$log_3 n$ 就等于 $log_3 2$ * $log_2 n$，所以 O($log_3 n$) = O(C * $log_2 n$)，其中 C=$log_3 2$ 是一个常量。

**O(m+n)、O(m*n)**

代码的复杂度由两个数据的规模来决定。

***空间复杂度分析***

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

我们常见的空间复杂度就是 O(1)、O(n)、O($n^2$ )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

***复杂度图表***

![复杂度图表](https://github.com/songor/algorithm-learned/blob/master/复杂度图表.jpg)